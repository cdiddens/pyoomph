General Information
-------------------

pyoomph is a library for Python which internally consists of two parts: The first part is a compiled dynamic library which contains a stripped version of the finite element toolbox oomph-lib and the required connection to expose it to Python via the library pybind11. The second part is a surrounding framework written in Python, where custom equations, a material library and further tools, like e.g. the calculation of activity coefficients via group contribution methods, are implemented. However, doing heavy computations (like the assembly of large residual vectors or Jacobian matrices) directly in Python is not desirable, since Python is a script language which is substantially slower than optimized compiled code. To that end, pyoomph also contains a just-in-time compilation step: All equations are defined and mutually linked across different physical domains in Python. The equations required in the physical system of interested are converted to C code via the library GiNaC. These C codes are compiled in the background and subsequently loaded back into pyoomph. This step happens automatically whenever a simulation is started. It might result in some seconds of waiting time for the compilation, but this pays off very quickly when multiple time steps or a large number of degrees of freedom are considered. In that sense, pyoomph has quite much in common with FEniCS, however with more focus on monolithic solving for coupled multi-physics domains and less focus on a comprehensive zoo of all kind of possible finite element spaces.
